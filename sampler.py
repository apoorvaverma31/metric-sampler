import torch
import numpy as np
import utils
from torch.utils.data import Dataset
from collections import Counter
import matplotlib.pyplot as plt
import time

class UnlabeledDatasetCollate(Dataset):
    """
    Class for collating the pseudo label-image pairs after target-distribution dependent sampling
    Returns a dataset object that can be passed into a dataloader directly
    """
    def __init__(self, labels_list, images_list, transform=None, target_transform=None):
        """
        Args:
            labels_list (list): list of labels obtained after sampling
            images_list (list): list of images corresponding to the labels sampled
            transform, target_transform (torch.nn.Sequential, optional): if we intend to apply any transforms on 
            the sampled images. Defaults to None.
        """
        self.labels_list = labels_list
        self.images_list = images_list
        self.transform = transform
        self.target_transform = target_transform

    def __len__(self):
        return len(self.labels_list) 

    def __getitem__(self, idx):
        image = self.images_list[idx]
        label = self.labels_list[idx]
        if self.transform:
            image = self.transform(image)
        if self.target_transform:
            label = self.target_transform(label)
        return image, label


class UnlabeledDataLoader():

    def __init__(self, ulb_dataset, model, target_dist, labeled_prior, batch_size):
        super(UnlabeledDataLoader, self).__init__()
        
        self.model = model
        self.ulb_dataset = ulb_dataset
        self.target_dist = target_dist
        self.batch_size = batch_size
        self.labeled_prior = labeled_prior
        self.pseudo_labels = self.gen_pl()
        self.ulb_dataset.targets = self.pseudo_labels
        self.loaders = self.get_loaders()
    
    def gen_pl(self):
        list_labels = []
        ulb_loader = torch.utils.data.DataLoader(self.ulb_dataset, batch_size= 128, num_workers=8, shuffle=True)
        for img, _, _ in ulb_loader:
            img = img.cuda()
            self.model.eval()
            pred, _ = self.model(img)
            pred = torch.argmax(pred, dim=1)
            list_labels.append(pred.cpu().numpy().flatten())
        list_labels = np.concatenate(list_labels).ravel().tolist()
        return list_labels
            
    def get_loaders(self):
        """
        Returns a dict of (num_classes) dataloaders of batch size 1 depending on the target distribution

        Args:
            num_classes (int): number of dataloaders (equal to number of classes in the dataset)
            pseudo_labels (list): list of pseudo-labels generated by the model
            target_dist (tensor): target distribution obtained by dM/dCij

        Returns:
            dict: dictionary of num_classes loaders
        """
        loader_dict = {}
        for i in range(self.target_dist.shape[0]):
            pl_weights = self.get_weights(i)
            sampler = torch.utils.data.WeightedRandomSampler(weights= pl_weights, num_samples = len(self.pseudo_labels), replacement = True)
            loader = torch.utils.data.DataLoader(self.ulb_dataset, batch_size=None, num_workers=8, sampler=sampler)
            loader_dict.update({f"{i}":iter(loader)})
        return loader_dict

        

    def get_weights(self, lbl):
        """Returns the sampling weights for each data instance in the dataset 

        Args:
            pseudo_labels (list): list of pseudo-labels generated by the model
            lbl (tensor): labels present in one batch obtained from the dataloader
            target_dist (tensor): target distribution obtained by dM/dCij

        Returns:
            list: list of instance-wise weights to be passed into the sampler
        """

        wts = []
        for t in self.pseudo_labels:
            wts.append(float(self.target_dist[lbl][t])/self.labeled_prior[t])
        return wts

    def get_batch(self, labels):
        """Returns a batch of unlabeled images and their pseudo labels sampled from a distribution dependent 

        Args:
            labels (torch.tensor): labels obtained from one minibatch of the labeled loader

        Returns:
            img: torch.tensor of unlabeled images (shape NxCxHxW)
            lbl_ulb: torch tensor of sampled pseudo labels (shape Nx1) 
        """
        sl_list = []
        image_list = []
        # t1 = time.time()
        for i in labels:
            image , sampled_label, _ = next(self.loaders[f'{i}'])
            sl_list.append(int(sampled_label)) 
            image_list.append(image)
        t2 = time.time()
        sl_list = torch.tensor(sl_list)
        image_list = torch.stack(image_list)
        # t3 = time.time()

        # print(t3-t2, t2-t1)
    
        return image_list, sl_list

if(__name__=="__main__"):
    print('work in progress')