import torch
import numpy as np
import utils
from torch.utils.data import Dataset
from collections import Counter
import matplotlib.pyplot as plt


class UnlabeledDataLoader():

    def __init__(self, ulb_dataset, model, target_dist, labeled_prior, batch_size):
        super(UnlabeledDataLoader, self).__init__()
        
        self.model = model
        self.ulb_dataset = ulb_dataset
        self.target_dist = target_dist
        self.batch_size = batch_size
        self.labeled_prior = labeled_prior
        self.pseudo_labels = self.gen_pl()
        self.ulb_dataset.targets = self.pseudo_labels
        self.loaders = self.get_loaders()
    
    def gen_pl(self):
        list_labels = []
        ulb_loader = torch.utils.data.DataLoader(self.ulb_dataset, batch_size= 128, num_workers=8, shuffle=True)
        for img, _, _ in ulb_loader:
            img = img.cuda()
            self.model.eval()
            pred, _ = self.model(img)
            pred = torch.argmax(pred, dim=1)
            list_labels.append(pred.cpu().numpy().flatten())
        list_labels = np.concatenate(list_labels).ravel().tolist()
        return list_labels
            
    def get_loaders(self):
        """
        Returns a dict of (num_classes) dataloaders of batch size 1 depending on the target distribution

        Args:
            num_classes (int): number of dataloaders (equal to number of classes in the dataset)
            pseudo_labels (list): list of pseudo-labels generated by the model
            target_dist (tensor): target distribution obtained by dM/dCij

        Returns:
            dict: dictionary of num_classes loaders
        """
        loader_dict = {}
        for i in range(self.target_dist.shape[0]):
            pl_weights = self.get_weights(i)
            sampler = torch.utils.data.WeightedRandomSampler(weights= pl_weights, num_samples = len(self.pseudo_labels), replacement = True)
            loader = torch.utils.data.DataLoader(self.ulb_dataset, batch_size=None, num_workers=8, sampler=sampler)
            loader_dict.update({f"{i}":iter(loader)})
        return loader_dict

        

    def get_weights(self, lbl):
        """Returns the sampling weights for each data instance in the dataset 

        Args:
            pseudo_labels (list): list of pseudo-labels generated by the model
            lbl (tensor): labels present in one batch obtained from the dataloader
            target_dist (tensor): target distribution obtained by dM/dCij

        Returns:
            list: list of instance-wise weights to be passed into the sampler
        """

        wts = []
        for t in self.pseudo_labels:
            wts.append(float(self.target_dist[lbl][t])/self.labeled_prior[t])
        return wts

    def get_batch(self, labels):
        """Returns a batch of unlabeled images and their pseudo labels sampled from a distribution dependent 

        Args:
            labels (torch.tensor): labels obtained from one minibatch of the labeled loader

        Returns:
            img: torch.tensor of unlabeled images (shape NxCxHxW)
            lbl_ulb: torch tensor of sampled pseudo labels (shape Nx1) 
        """
        sl_list = []
        image_list = []
        
        for i in labels:
            image , sampled_label, _ = next(self.loaders[f'{i}'])
            sl_list.append(int(sampled_label)) 
            image_list.append(image)

        sl_list = torch.tensor(sl_list)
        image_list = torch.stack(image_list)
    
        return image_list, sl_list

class UnlabeledDataLoader_test():

    def __init__(self, ulb_dataset, target_dist, labeled_prior, batch_size):
        super(UnlabeledDataLoader_test, self).__init__()
        
        self.ulb_dataset = ulb_dataset
        self.target_dist = target_dist
        self.batch_size = batch_size
        self.labeled_prior = labeled_prior
        self.pseudo_labels = self.ulb_dataset.targets 
        self.loaders = self.get_loaders()
    
            
    def get_loaders(self):
        """
        Returns a dict of (num_classes) dataloaders of batch size 1 depending on the target distribution

        Args:
            num_classes (int): number of dataloaders (equal to number of classes in the dataset)
            pseudo_labels (list): list of pseudo-labels generated by the model
            target_dist (tensor): target distribution obtained by dM/dCij

        Returns:
            dict: dictionary of num_classes loaders
        """
        loader_dict = {}
        for i in range(self.target_dist.shape[0]):
            pl_weights = self.get_weights(i)
            sampler = torch.utils.data.WeightedRandomSampler(weights= pl_weights, num_samples = len(self.pseudo_labels), replacement = True)
            loader = torch.utils.data.DataLoader(self.ulb_dataset, batch_size=None, num_workers=8, sampler=sampler)
            loader_dict.update({f"{i}":iter(loader)})
        return loader_dict

        

    def get_weights(self, lbl):
        """Returns the sampling weights for each data instance in the dataset 

        Args:
            pseudo_labels (list): list of pseudo-labels generated by the model
            lbl (tensor): labels present in one batch obtained from the dataloader
            target_dist (tensor): target distribution obtained by dM/dCij

        Returns:
            list: list of instance-wise weights to be passed into the sampler
        """

        wts = []
        for t in self.pseudo_labels:
            wts.append(float(self.target_dist[lbl][t])/self.labeled_prior[t])
        return wts

    def get_batch(self, labels):
        """Returns a batch of unlabeled images and their pseudo labels sampled from a distribution dependent 

        Args:
            labels (torch.tensor): labels obtained from one minibatch of the labeled loader

        Returns:
            img: torch.tensor of unlabeled images (shape NxCxHxW)
            lbl_ulb: torch tensor of sampled pseudo labels (shape Nx1) 
        """
        sl_list = []
        image_list = []
        
        for i in labels:
            image , sampled_label, _ = next(self.loaders[f'{i}'])
            sl_list.append(int(sampled_label)) 
            image_list.append(image)

        sl_list = torch.tensor(sl_list)
        image_list = torch.stack(image_list)
    
        return image_list, sl_list

if(__name__=="__main__"):
    print('work in progress')